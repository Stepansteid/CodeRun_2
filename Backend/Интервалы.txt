Ссылка на задачу: https://coderun.yandex.ru/selections/2024-summer-backend/problems/invervals?currentPage=1&difficulty=HARD&pageSize=20&search=
При первом переходе на страничку сайта можно заметить, что задача из разряда "Cложная". Является ли она на самом деле сложной и в чем тогда заключается ее сложность? 

Заметим, что ...

После уже прочтения задачи внимательный читатель, который уже думает как это перебирать, заметит ограничения, которые даются в задаче на входные данные, а именно: n, m <= 300.
Что же это может значить? Ну на самом деле тут можно сразу сказать, что, например, ассимптотика O(n * m) явно подойдет или же (n^2 * m) тоже должно зайти без особых проблем.
Очевидно, что нам нужно как-то найти число на которое нужно сдвинуть красные отрезки. Какие методы сразу приходят на ум, когда нам нужно найти какое-то число k, при котором некоторая функция от наших данных будет минимальна. Очевидно бинпоиск, ноо..... Где тут выпуклая функция? Может быть ДП? Да, тоже нет переход от одного состояния к другому за быстрое время как-то не очевиден, а сколько у нас вообще состояний. Ответ в том, какой подход использовать исходит от ограничений на данных в этой задаче. Допустим, мы хотим попробовать какой-то сдвиг на k. Тогда длину пересечений отрезков я смогу найти быстро за O(n + m). Задаем себе вопрос: а какое количество k я могу перепробовать. Например n * m можно. А уже n^2 * m  вряд ли.


Лемма.
Оптимальный вариант сдвига достигается, когда конец какого-нибудь красного отрезка совпадает с концом синего или наоборот: конец синего совпадает с концом красного или же начало или конец крайних отрезков совпадает с концами допустимого отрезка [L, R]. 
Потому что иначе мы можем передвинуть их и только улучшим свой ответ.


